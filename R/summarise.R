#' Stepwise summarise data from spiroergometric tests
#'
#' \code{spiro_summary()} returns a \code{data.frame} summarising the main
#' parameters for each step of a spiroergometric test.
#'
#' This function generates mean values of gas exchange and cardiac parameters
#' for all steps of a spiroergometric test. For calculation the given
#' \code{interval} before the end of each step is used.
#'
#' If the interval exceeds the duration of any step, a message will be
#' displayed. If the interval exceeds the duration of all steps, it will be
#' reset to the duration of the longest step. You can turn off any messages by
#' setting `quiet = TRUE`.
#'
#' When setting `exclude = TRUE` the function will check whether the last load
#' step was early terminated. If this was the case, it will not be displayed in
#' the summary.
#'
#' @param data A \code{data.frame} of the class \code{spiro_*}, as it is
#'   generated by \code{\link{spiro}}.
#' @param interval An integer giving the length of the computational
#'   interval in seconds.
#' @param quiet A logical value, whether or not messages should be displayed,
#'   for example when intervals were shortened for specific steps.
#' @param exclude A logical value, whether the last step should be excluded from
#'   the summary if it was not fully performed.
#'
#' @examples
#' # Import and process example data
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_summary(gxt_data)
#'
#' @export

spiro_summary <- function(data, interval = 120, quiet = FALSE, exclude = FALSE) {

  # step wise summary only works when load step are available
  protocol <- attr(data, "protocol")
  if (is.null(protocol))
    stop("No protocol found")

  # special handle, if all load steps are less than interval
  # interval will be given the value of the longest step
  if (all(protocol$duration[protocol$type == "load"] < interval)) {
    interval <- max(protocol$duration[protocol$type == "load"])
    if (!quiet) {
      message(sprintf("for load steps, interval was set to %s seconds", interval))
    }
  }

  # optionally exclude non-finished last load step
  if (exclude) {
    # get all durations of load steps
    all_durations <- protocol$duration[protocol$code > 0]
    # check if last step was shorter than all other steps
    if (all(all_durations[length(all_durations)] < all_durations[-length(all_durations)])) {
      data <- data[data$step != max(data$step),] # exclude step
      if (!quiet) {
        message("Last step was excluded from summary calculation due to termination of the test")
      }
    }
  }

  out <- sapply(unique(data$step)[unique(data$step) >= 0], getstepmeans,
                data = data,
                interval = interval,
                quiet = quiet)
  out_df <- data.frame(apply(t(out),2,unlist))

  # round values to two decimals
  out_df[,!colnames(out_df) %in% c("step_number","load")] <- round(out_df[,!colnames(out_df) %in% c("step_number","load")],2)

  # write calculation interval as attribute (useful for reactive environments)
  attr(out_df,"interval") <- interval

  out_df
}

#' Return maximum values from spiroergometric tests
#'
#' \code{spiro_max()} returns a \code{data.frame} with the maximum parameter
#' parameters of a spiroergometric test.
#'
#' Before calculating the maximum values, data is smoothed by using a rolling
#' average over the length of \code{interval}.
#'
#' @param data A \code{data.frame} of the class \code{spiro}, as it is
#'   generated by \code{\link{spiro}}.
#' @param smooth An integer, giving the length of the computational
#'   interval for the rolling average.
#' @param hr_smooth A logical, whether smoothing should also apply to heart rate
#'   data. Default is `FALSE`, which means that the absolute maximum heart rate
#'   value is taken without smoothing.
#'
#' @examples
#' # Import and process example data sets
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_max(gxt_data)
#'
#' @export

spiro_max <- function(data, smooth = 30, hr_smooth = FALSE) {

  # calculate rolling averages
  data$VO2_rm <- zoo::rollmean(data$VO2, smooth, na.pad = TRUE)
  data$VCO2_rm <- zoo::rollmean(data$VCO2, smooth, na.pad = TRUE)
  data$VO2_rel_rm <- zoo::rollmean(data$VO2_rel, smooth, na.pad = TRUE)
  data$VE_rm <- zoo::rollmean(data$VE, smooth, na.pad = TRUE)
  data$RER_rm <- zoo::rollmean(data$RER, smooth, na.pad = TRUE)

  # Use only data during exercising for calculating maximum values
  # Does not apply to HR, since this can also be achieved shortly after
  # termination
  if (any(data$step != 0)) data_cut <- data[data$step >= 1,]

  df <- data.frame(
    VO2 = max(data_cut$VO2_rm, na.rm = TRUE),
    VCO2 = max(data_cut$VCO2_rm, na.rm = TRUE),
    VO2_rel = max(data_cut$VO2_rel_rm, na.rm = TRUE),
    VE = max(data_cut$VE_rm, na.rm = TRUE),
    RER = max(data_cut$RER_rm, na.rm = TRUE)
  )
  df <- round(df, 2) # round data to two decimals

  # check if HR data is available
  if (!all(is.na(data$HR))) {
    if (hr_smooth) {
      # apply smoothing to heart rate data
      hr_max <- round(max(zoo::rollmean(data$HR, smooth, na.pad = TRUE), na.rm = TRUE))
    } else {
      hr_max <- max(data$HR, na.rm = TRUE)
    }
    df_hr <- data.frame(HR = hr_max)
  } else {
    df_hr <- data.frame(HR = NA)
  }

  df <- cbind(df, df_hr)

  # write calculation interval as attribute (useful for reactive environments)
  attr(df,"interval") <- smooth

  df
}

#' Get mean data values for a step of an exercise test
#'
#' \code{getstepmeans()} returns the average data values for a single step of an
#' exercise test.
#'
#' @noRd
getstepmeans <- function(step_number, data, interval = 30, quiet = FALSE) {

  # filter data for desired step number and delete unneeded columns
  step <- data[data$step == step_number,
               !colnames(data) %in% c("step","time","VCO2_rel","RR","VT")]

  # get start of calculation interval
  if (nrow(step) >= interval) { # step longer than interval
    cstart <- nrow(step)-(interval-1)
  } else { # step shorter than interval
    cstart <- 1
    if (!quiet) {
      if (step_number == 0) { # pre measures
        message(
          sprintf(
            "for pre-measures, interval was set to length of measures (%s seconds)",
            nrow(step))
        )
      } else if (step_number == 0.5) { # warm up
        message(
          sprintf(
            "for warm-up measures, interval was set to length of warm-up (%s seconds)",
            nrow(step))
        )
      } else { # load steps
        message(
          sprintf(
            "for step %s, interval was set to length of step (%s seconds)",
            step_number, nrow(step))
        )
      }
    }
  }

  # filter data within calculation interval
  stepend <- step[cstart:nrow(step),]

  # calculate mean values
  df <- data.frame(
    step_number = step_number,
    t(colMeans(stepend, na.rm = TRUE))
  )

  # Replace missing values with NAs
  df[1,which(is.na(df))] <- NA

  df
}
