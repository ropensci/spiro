#' Stepwise summarise data from spiroergometric tests
#'
#' \code{spiro_summary()} returns a \code{data.frame} summarising the main
#' parameters for each step of a spiroergometric test.
#'
#' This function generates mean values of gas exchange and cardiac parameters
#' for all steps of a spiroergometric test. For calculation the given
#' \code{interval} before the end of each step is used.
#'
#' @param data A \code{data.frame} of the class \code{spiro_*}, as it is
#'   generated by \code{\link{spiro}}.
#' @param interval An integer giving the length of the computational
#'   interval in seconds.
#'
#' @examples
#' # Import and process example data
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_summary(gxt_data)
#'
#' @export

spiro_summary <- function(data, interval = 120) {
  protocol <- attr(data, "protocol")
  if (is.null(protocol))
    stop("No protocol found")

  predf <- NULL
  wudf <- NULL
  if (any(data$step == 0)) { # for pre measures
    pre_duration <- protocol$duration[[1]]
    if (pre_duration >= interval) {
      predf <- sapply(0, getstepmeans, data = data, interval = interval)
    } else { # computational interval longer than pre measures
    predf <- sapply(0, getstepmeans,
                    data = data,
                    interval = pre_duration)
    message(
      sprintf(
      "for pre-measures, interval was set to length of measures (%s seconds)",
      pre_duration)
    )
    }
  }

  if (any(data$step == 0.5)) { # for warm up
    wu_duration <- protocol$duration[[which(protocol$code == 0.5)]]
    if (wu_duration >= interval) {
      wudf <- sapply(0.5, getstepmeans, data = data, interval = interval)
    } else { # computational interval longer than warm up
      predf <- sapply(0.5, getstepmeans,
                      data = data,
                      interval = wu_duration)
      message(
        sprintf(
         "for warm-up measures, interval was set to length of warm-up (%s seconds)",
         wu_duration)
      )
    }
  }

  # special handle, if all load steps are less than interval
  # interval will be given the value of the longest step
  if (all(protocol$duration[protocol$type == "load"] < interval)) {
    interval <- max(protocol$duration[protocol$type == "load"])
    message(sprintf("for load steps, interval was set to %s seconds", interval))
  }

  # for load steps
  # compare step lengths and computational interval
  step_interval <- vector(mode = "numeric", length = max(data$step))
  for (i in seq(max(data$step))) {
    i_duration <- protocol$duration[[which(protocol$code == i)]]
    if (i_duration >= interval) {
      step_interval[i] <- interval
    } else {
      step_interval[i] <- i_duration
      message(
        sprintf("for step %s, interval was set to length of step (%s seconds)",
                i, i_duration)
      )
    }
  }

  steps <- 1:max(data$step)
  ldf <- mapply(FUN = getstepmeans,
    step_number = steps,
    interval = step_interval,
    MoreArgs = list(data = data)
  )
  ldf <- cbind(predf, wudf, ldf)
  df <- round(data.frame(apply(t(ldf),2,unlist)),2)
  attr(df,"interval") <- interval
  df
}

#' Overall summarise data from spiroergometric tests
#'
#' \code{spiro_glance()} returns a \code{data.frame} overall summarising the
#' parameters of a spiroergometric test.
#'
#' This function generates a overall summary of gas exchange and cardiac
#' parameters for spiroergometric tests.
#'
#' For constant load tests, the mean parameters for the given load are
#' calculated over all steps. The length of the computational interval before
#' the end of each step is given by \code{interval}.
#'
#' For other test protocols, the maximum parameters are calculated. Data is
#' smoothed before by using a rolling average over the length of
#' \code{interval}.
#'
#' @param data A \code{data.frame} of the class \code{spiro_*}, as it is
#'   generated by \code{\link{spiro}}.
#' @param interval An integer, giving the length of the computational
#'   interval in seconds.
#'
#' @examples
#' # Import and process example data sets
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_glance(gxt_data)
#'
#' @export

spiro_glance <- function(data, interval) {
  UseMethod("spiro_glance")
}


#' @describeIn spiro_glance The default method, which gives maximal values of
#'   the rolling averages.
#' @export

spiro_glance.default <- function(data, interval = 30) {
  data$VO2_rm <- zoo::rollmean(data$VO2, interval, na.pad = TRUE)
  data$VO2_rel_rm <- zoo::rollmean(data$VO2_rel, interval, na.pad = TRUE)
  data$RER_rm <- zoo::rollmean(data$RER, interval, na.pad = TRUE)

  # Use only data during exercising for calculating maximum values
  # Does not apply to HR, since this can also be archived shortly after
  # termination
  if (any(data$step != 0)) data_cut <- data[data$step >= 1,]

  df <- data.frame(
    VO2max_abs = max(data_cut$VO2_rm, na.rm = TRUE),
    VO2max_rel = max(data_cut$VO2_rel_rm, na.rm = TRUE),
    RER_max = max(data_cut$RER_rm, na.rm = TRUE)
  )
  df <- round(df, 2)

  if (!all(data$HR == 0, na.rm = TRUE)) {
    df_hr <- data.frame(HR_max = max(data$HR, na.rm = TRUE))
    df <- cbind(df, df_hr)
  }

  if (is.null(attr(data, "testtype"))) {
    colnames(df) <- c("VO2peak_abs","VO2peak_rel","RER_peak")
    if (ncol(df) == 4) colnames(df)[4] <- "HR_peak"
  } else if (attr(data, "testtype") == "incremental") {
    colnames(df) <- c("VO2peak_abs","VO2peak_rel","RER_peak")
    if (ncol(df) == 4) colnames(df)[4] <- "HR_peak"
  }

  attr(df,"interval") <- interval
  df
}

#' @describeIn spiro_glance Method for constant load tests, which gives an
#'   average of all steps performed at the constant load.
#' @export
spiro_glance.spiro_clt <- function(data, interval = 120) {
  steps <- 1:max(data$step)
  ldf <- sapply(steps, getstepmeans, data = data, interval = interval)
  m <- apply(ldf,2,unlist)
  mm <- round(rowMeans(m),2)[-1]
  df_out <- data.frame(t(mm))
  attr(df_out,"interval") <- interval
  df_out
}

#' Get mean data values for a step of an exercise test
#'
#' \code{getstepmeans()} returns the average data values for a single step of an
#' exercise test.
#'
#' @param step_number An integer giving the number of the step
#' @param data A \code{data.frame} of the class \code{exed_*} containing the
#'    data of the test
#' @param interval An integer giving the length of the computational interval
#'    in seconds. For calculation the last \code{interval} seconds of the step
#'    will be averaged.
getstepmeans <- function(step_number, data, interval = 30) {
  step <- data[data$step == step_number,]
  stepend <- step[(nrow(step)-(interval-1)):nrow(step),]

  df <- data.frame(
    step_number = step_number,
    load = mean(stepend$load, na.rm = TRUE),
    VE = mean(stepend$VE, na.rm = TRUE),
    VO2 = mean(stepend$VO2, na.rm = TRUE),
    VCO2 = mean(stepend$VCO2, na.rm = TRUE),
    RER = mean(stepend$RER, na.rm = TRUE),
    VO2_rel = mean(stepend$VO2_rel, na.rm = TRUE),
    RE = mean(stepend$RE, na.rm = FALSE),
    CHO = mean(stepend$CHO, na.rm = TRUE),
    FO = mean(stepend$FO, na.rm = TRUE)
  )

  if (!all(data$HR == 0, na.rm = TRUE)) {
    df_hr <- data.frame(HR = mean(stepend$HR, na.rm = FALSE))
    df <- cbind(df, df_hr)
  }
  df
}
