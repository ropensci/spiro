#' Stepwise summarise data from spiroergometric tests
#'
#' \code{spiro_summary()} returns a \code{data.frame} summarising the main
#' parameters for each step of a spiroergometric test.
#'
#' This function generates mean values of gas exchange and cardiac parameters
#' for all steps of a spiroergometric test. For calculation the given
#' \code{interval} before the end of each step is used.
#'
#' @param data A \code{data.frame} of the class \code{spiro_*}, as it is
#'   generated by \code{\link{spiro}}.
#' @param interval An integer giving the length of the computational
#'   interval in seconds.
#'
#' @examples
#' # Import and process example data
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_summary(gxt_data)
#'
#' @export

spiro_summary <- function(data, interval = 120) {
  # step wise summary only works when load step are available
  protocol <- attr(data, "protocol")
  if (is.null(protocol))
    stop("No protocol found")

  predf <- NULL
  wudf <- NULL
  if (any(data$step == 0)) { # for pre measures
    pre_duration <- protocol$duration[[1]]
    if (pre_duration >= interval) {
      predf <- sapply(0, getstepmeans, data = data, interval = interval)
    } else { # computational interval longer than pre measures
    predf <- sapply(0, getstepmeans,
                    data = data,
                    interval = pre_duration)
    message(
      sprintf(
      "for pre-measures, interval was set to length of measures (%s seconds)",
      pre_duration)
    )
    }
  }

  if (any(data$step == 0.5)) { # for warm up
    wu_duration <- protocol$duration[[which(protocol$code == 0.5)]]
    if (wu_duration >= interval) {
      wudf <- sapply(0.5, getstepmeans, data = data, interval = interval)
    } else { # computational interval longer than warm up
      predf <- sapply(0.5, getstepmeans,
                      data = data,
                      interval = wu_duration)
      message(
        sprintf(
         "for warm-up measures, interval was set to length of warm-up (%s seconds)",
         wu_duration)
      )
    }
  }

  # special handle, if all load steps are less than interval
  # interval will be given the value of the longest step
  if (all(protocol$duration[protocol$type == "load"] < interval)) {
    interval <- max(protocol$duration[protocol$type == "load"])
    message(sprintf("for load steps, interval was set to %s seconds", interval))
  }

  # for load steps
  # compare step lengths and computational interval
  step_interval <- vector(mode = "numeric", length = max(data$step))
  for (i in seq(max(data$step))) {
    i_duration <- protocol$duration[[which(protocol$code == i)]]
    if (i_duration >= interval) {
      step_interval[i] <- interval
    } else {
      step_interval[i] <- i_duration
      message(
        sprintf("for step %s, interval was set to length of step (%s seconds)",
                i, i_duration)
      )
    }
  }

  steps <- 1:max(data$step)
  ldf <- mapply(FUN = getstepmeans,
    step_number = steps,
    interval = step_interval,
    MoreArgs = list(data = data)
  )
  ldf <- cbind(predf, wudf, ldf)
  df <- round(data.frame(apply(t(ldf),2,unlist)),2)
  attr(df,"interval") <- interval
  df
}

#' Return maximum values from spiroergometric tests
#'
#' \code{spiro_max()} returns a \code{data.frame} with the maximum parameter
#' parameters of a spiroergometric test.
#'
#' Before calculating the maximum values, data is smoothed by using a rolling
#' average over the length of \code{interval}.
#'
#' @param data A \code{data.frame} of the class \code{spiro}, as it is
#'   generated by \code{\link{spiro}}.
#' @param interval An integer, giving the length of the computational
#'   interval in seconds.
#'
#' @examples
#' # Import and process example data sets
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_max(gxt_data)
#'
#' @export

spiro_max <- function(data, interval = 30) {

  # calculate rolling averages
  data$VO2_rm <- zoo::rollmean(data$VO2, interval, na.pad = TRUE)
  data$VCO2_rm <- zoo::rollmean(data$VCO2, interval, na.pad = TRUE)
  data$VO2_rel_rm <- zoo::rollmean(data$VO2_rel, interval, na.pad = TRUE)
  data$VE_rm <- zoo::rollmean(data$VE, interval, na.pad = TRUE)
  data$RER_rm <- zoo::rollmean(data$RER, interval, na.pad = TRUE)

  # Use only data during exercising for calculating maximum values
  # Does not apply to HR, since this can also be achieved shortly after
  # termination
  if (any(data$step != 0)) data_cut <- data[data$step >= 1,]

  df <- data.frame(
    VO2 = max(data_cut$VO2_rm, na.rm = TRUE),
    VCO2 = max(data_cut$VCO2_rm, na.rm = TRUE),
    VO2_rel = max(data_cut$VO2_rel_rm, na.rm = TRUE),
    VE = max(data_cut$VE_rm, na.rm = TRUE),
    RER = max(data_cut$RER_rm, na.rm = TRUE)
  )
  df <- round(df, 2) # round data to two decimals

  # calculate maximum heartrate without rolling average
  if (!all(data$HR == 0, na.rm = TRUE)) {
    df_hr <- data.frame(HR = max(data$HR, na.rm = TRUE))
  } else {
    df_hr <- data.frame(HR = NA)
  }
  df <- cbind(df, df_hr)

  # write calculation interval as attribute (useful for reactive environments)
  attr(df,"interval") <- interval

  df
}

spiro_temp <- function(data, interval = 120) {

  protocol <- attr(data, "protocol")
  if (is.null(protocol))
    stop("No protocol found")

  # check if the last step was completed
  last_duration <- protocol$duration[[which(protocol$code == max(data$step))]]

  # if last step was shorter than calculation interval (early termination)
  # this step will be excluded from the calculation of the overall summary
  if (last_duration < interval) {
    steps <- 1:(max(data$step - 1))
    message("Last step was excluded from summary calculation due to termination of the test")
  } else {
    steps <- 1:max(data$step)
  }
  ldf <- sapply(steps, getstepmeans, data = data, interval = interval)
  m <- apply(ldf,2,unlist)
  mm <- round(rowMeans(m),2)[-1]
  df_out <- data.frame(t(mm))
  attr(df_out,"interval") <- interval
  df_out
}

#' Get mean data values for a step of an exercise test
#'
#' \code{getstepmeans()} returns the average data values for a single step of an
#' exercise test.
#'
#' @param step_number An integer giving the number of the step
#' @param data A \code{data.frame} of the class \code{exed_*} containing the
#'    data of the test
#' @param interval An integer giving the length of the computational interval
#'    in seconds. For calculation the last \code{interval} seconds of the step
#'    will be averaged.
getstepmeans <- function(step_number, data, interval = 30) {
  step <- data[data$step == step_number,]

  # get start of calculation interval
  if (nrow(step) >= interval) {
    cstart <- nrow(step)-(interval-1)
  } else { # special case if last step was shorter than interval
    cstart <- 1
  }
  stepend <- step[cstart:nrow(step),]

  df <- data.frame(
    step_number = step_number,
    load = mean(stepend$load, na.rm = TRUE),
    VE = mean(stepend$VE, na.rm = TRUE),
    VO2 = mean(stepend$VO2, na.rm = TRUE),
    VCO2 = mean(stepend$VCO2, na.rm = TRUE),
    RER = mean(stepend$RER, na.rm = TRUE),
    VO2_rel = mean(stepend$VO2_rel, na.rm = TRUE),
    RE = mean(stepend$RE, na.rm = FALSE),
    CHO = mean(stepend$CHO, na.rm = TRUE),
    FO = mean(stepend$FO, na.rm = TRUE)
  )

  if (!all(data$HR == 0, na.rm = TRUE)) {
    df_hr <- data.frame(HR = mean(stepend$HR, na.rm = FALSE))
    df <- cbind(df, df_hr)
  }
  df
}
