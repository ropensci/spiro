#' Return maximum values from spiroergometric tests
#'
#' \code{spiro_max()} returns a \code{data.frame} with the maximum parameter
#' parameters of a spiroergometric test.
#'
#' Before calculating the maximum values, data is smoothed by using a rolling
#' average over the a desired time interval or number of breaths. Set
#' \code{smooth} to integer for a time-dependent averaging process, use a
#' character vector where the letter 'b' follows an integer for breath-dependent
#' averaging.
#'
#' @param data A \code{data.frame} of the class \code{spiro}, as it is
#'   generated by \code{\link{spiro}}.
#' @param smooth Parameter giving the length and method for the computational
#'   interval of the rolling average. Use an integer for smoothing by seconds,
#'   use a character such as \code{"30b"} for smoothing by the number of
#'   breaths. Default is time averaging by 30 seconds.
#' @param hr_smooth A logical, whether smoothing should also apply to heart rate
#'   data. Default is `FALSE`, which means that the absolute maximum heart rate
#'   value is taken without smoothing.
#'
#' @return A \code{data.frame} with the maximum parameter values of the data.
#'
#' @examples
#' # Import and process example data sets
#' gxt_data <- spiro(file = spiro_example("zan_gxt"))
#'
#' spiro_max(gxt_data)
#'
#' # Use an averaging over a time interval of 15 seconds
#' spiro_max(gxt_data, smooth = 15)
#'
#' # Use an averaging over an interval of 15 breaths
#' spiro_max(gxt_data, smooth = "15b")
#' @export

spiro_max <- function(data, smooth = 30, hr_smooth = FALSE) {

  # input validation for `smooth` argument

  # check if breath averaging was chosen
  if (grepl("b$", smooth)) {
    b_smooth <- TRUE # smooth method: breath averaging
    smooth <- gsub("b", "", smooth)
  } else {
    b_smooth <- FALSE # smooth method: time averaging
  }

  # validate if 'smooth' can be interpreted as an integer
  smooth <- suppressWarnings(as.numeric(smooth))
  if (!is.numeric(smooth) || is.na(smooth)) {
    stop(
      paste0(
        "'smooth' must be an integer for smoothing by type or a string ",
        "containing an integer followed by the letter 'b' for smoothing by ",
        "breathes"
      )
    )
  } else if (smooth < 1) {
    stop("'smooth' must be greater or equal to 1")
  }

  if (!is.logical(hr_smooth)) {
    stop("'hr_smooth' must be either TRUE or FALSE")
  }

  # use raw data for smoothing by breathes
  # to later remove data from periods of no load for the calculation of maximum
  # values, the load information from the interpolated data are matched to the
  # breath-by-breath data
  if (b_smooth) {
    step_data <- data$step
    weight <- attr(data, "info")$weight
    data <- attr(data, "raw")
    # set empty step data for the rare case if raw data is longer by one value
    # than the interpolated (protocol) data
    data$step <- 0
    matched_step_data <- step_data[round(data$time, 0)]
    data$step[seq_along(matched_step_data)] <- matched_step_data

    # check if data is breath by breath. If this in the not the case a
    # breath-averaging is not possible
    bb <- check_bb(data$time)
    if (!bb) {
      stop(
        paste0(
          "Could not perform breath-averaging. ",
          "It seems like your data was not recorded breath-by-breath."
        )
      )
    }

    # calculate RER and VO2_rel, which are not present in the raw
    # breath-by-breath data
    data$RER <- data$VCO2 / data$VO2
    data$RER[which(is.na(data$RER))] <- NA
    data$VO2_rel <- data$VO2 / weight
  }

  # calculate rolling averages
  data$VO2_rm <- zoo::rollmean(data$VO2, smooth, fill = NA)
  data$VCO2_rm <- zoo::rollmean(data$VCO2, smooth, fill = NA)
  data$VO2_rel_rm <- zoo::rollmean(data$VO2_rel, smooth, fill = NA)
  data$VE_rm <- zoo::rollmean(data$VE, smooth, fill = NA)
  data$RER_rm <- zoo::rollmean(data$RER, smooth, fill = NA)

  # Use only data during exercising for calculating maximum values
  # Does not apply to HR, since this can also be achieved shortly after
  # termination
  if (any(data$step != 0)) {
    data_cut <- data[data$step >= 1, ]
  } else {
    data_cut <- data
  }

  df <- data.frame(
    VO2 = max(data_cut$VO2_rm, na.rm = TRUE),
    VCO2 = max(data_cut$VCO2_rm, na.rm = TRUE),
    VO2_rel = max(data_cut$VO2_rel_rm, na.rm = TRUE),
    VE = max(data_cut$VE_rm, na.rm = TRUE),
    RER = max(data_cut$RER_rm, na.rm = TRUE)
  )
  df <- round(df, 2) # round data to two decimals

  # check if HR data is available
  if (!all(is.na(data$HR))) {
    if (hr_smooth) {
      # apply smoothing to heart rate data
      hr_max <- round(
        max(zoo::rollmean(data$HR, smooth, fill = NA),
          na.rm = TRUE
        )
      )
    } else {
      hr_max <- max(data$HR, na.rm = TRUE)
    }
    df_hr <- data.frame(HR = hr_max)
  } else {
    df_hr <- data.frame(HR = NA)
  }

  df <- cbind(df, df_hr)

  # write smoothing interval and methods as attribute (useful for reactive
  # environments)
  if (b_smooth) smooth_method <- "breath" else smooth_method <- "time"
  smooth_attribute <- data.frame(interval = smooth, method = smooth_method)
  attr(df, "interval") <- smooth_attribute

  df
}
